import * as cdk from "aws-cdk-lib";
import * as cloudmap from "aws-cdk-lib/aws-servicediscovery";
import * as ec2 from "aws-cdk-lib/aws-ec2";
import * as ecr from "aws-cdk-lib/aws-ecr";
import * as ecs from "aws-cdk-lib/aws-ecs";
import * as elbv2 from "aws-cdk-lib/aws-elasticloadbalancingv2";
import * as iam from "aws-cdk-lib/aws-iam";
import * as logs from "aws-cdk-lib/aws-logs";
import * as rds from "aws-cdk-lib/aws-rds";
import * as route53 from "aws-cdk-lib/aws-route53";
import * as route53Targets from "aws-cdk-lib/aws-route53-targets";
import * as secretsmanager from "aws-cdk-lib/aws-secretsmanager";
import { Construct } from "constructs";

export interface CrackosaurusStackProps extends cdk.StackProps {
  environmentName: string;
  domainName?: string;
  certificateArn?: string;
  hostedZoneId?: string;
  dbPassword?: string;
}

export class CrackosaurusStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: CrackosaurusStackProps) {
    super(scope, id, props);

    const { environmentName, domainName } = props;
    const isProduction = environmentName === "prod";

    // ===========================================
    // VPC and Networking
    // ===========================================
    const vpc = new ec2.Vpc(this, "VPC", {
      maxAzs: 2,
      // Budget mode: No NAT Gateway saves ~$35/month
      // Tasks will run in public subnets with public IPs
      natGateways: budgetMode ? 0 : 1,
      subnetConfiguration: [
        {
          cidrMask: 24,
          name: "Public",
          subnetType: ec2.SubnetType.PUBLIC,
        },
        {
          cidrMask: 24,
          name: "Private",
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        {
          cidrMask: 28,
          name: "Isolated",
          subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
        },
      ],
    });

    // Service Discovery Namespace
    const namespace = new cloudmap.PrivateDnsNamespace(this, "ServiceNamespace", {
      name: "crackosaurus.local",
      vpc,
    });

    // ===========================================
    // Security Groups
    // ===========================================
    const albSecurityGroup = new ec2.SecurityGroup(this, "ALBSecurityGroup", {
      vpc,
      description: "Security group for Application Load Balancer",
      allowAllOutbound: true,
    });
    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(80),
      "Allow HTTP traffic"
    );
    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      "Allow HTTPS traffic"
    );

    const serverSecurityGroup = new ec2.SecurityGroup(this, "ServerSecurityGroup", {
      vpc,
      description: "Security group for server containers",
      allowAllOutbound: true,
    });
    serverSecurityGroup.addIngressRule(
      albSecurityGroup,
      ec2.Port.tcp(8080),
      "Allow traffic from ALB"
    );

    const clusterSecurityGroup = new ec2.SecurityGroup(this, "ClusterSecurityGroup", {
      vpc,
      description: "Security group for cluster containers",
      allowAllOutbound: true,
    });
    clusterSecurityGroup.addIngressRule(
      serverSecurityGroup,
      ec2.Port.tcp(13337),
      "Allow traffic from server"
    );

    const dbSecurityGroup = new ec2.SecurityGroup(this, "DBSecurityGroup", {
      vpc,
      description: "Security group for RDS database",
      allowAllOutbound: false,
    });
    dbSecurityGroup.addIngressRule(
      serverSecurityGroup,
      ec2.Port.tcp(5432),
      "Allow PostgreSQL from server"
    );
    dbSecurityGroup.addIngressRule(
      clusterSecurityGroup,
      ec2.Port.tcp(5432),
      "Allow PostgreSQL from cluster"
    );

    // ===========================================
    // Database (RDS PostgreSQL)
    // ===========================================
    const dbSecret = new secretsmanager.Secret(this, "DBSecret", {
      secretName: `crackosaurus/${environmentName}/db-password`,
      description: "Database password for Crackosaurus",
      generateSecretString: {
        secretStringTemplate: JSON.stringify({ username: "postgres" }),
        generateStringKey: "password",
        excludePunctuation: true,
        passwordLength: 32,
      },
    });

    const database = new rds.DatabaseInstance(this, "Database", {
      engine: rds.DatabaseInstanceEngine.postgres({
        version: rds.PostgresEngineVersion.VER_16_1,
      }),
      // Budget mode: db.t3.micro (~$15/month) vs db.t3.medium (~$50/month)
      instanceType: ec2.InstanceType.of(
        ec2.InstanceClass.T3,
        budgetMode ? ec2.InstanceSize.MICRO : (isProduction ? ec2.InstanceSize.MEDIUM : ec2.InstanceSize.MICRO)
      ),
      vpc,
      vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },
      securityGroups: [dbSecurityGroup],
      databaseName: "crackosaurus",
      credentials: rds.Credentials.fromSecret(dbSecret),
      // Budget mode: Minimal storage
      allocatedStorage: budgetMode ? 20 : (isProduction ? 100 : 20),
      maxAllocatedStorage: budgetMode ? 50 : (isProduction ? 500 : 100),
      // Budget mode: Single-AZ (no high availability, saves 50%)
      multiAz: budgetMode ? false : isProduction,
      backupRetention: cdk.Duration.days(budgetMode ? 1 : (isProduction ? 7 : 1)),
      deleteAutomatedBackups: !isProduction || budgetMode,
      removalPolicy:
        isProduction && !budgetMode
          ? cdk.RemovalPolicy.SNAPSHOT
          : cdk.RemovalPolicy.DESTROY,
      deletionProtection: isProduction && !budgetMode,
    });

    // ===========================================
    // ECS Cluster
    // ===========================================
    const ecsCluster = new ecs.Cluster(this, "Cluster", {
      vpc,
      clusterName: `crackosaurus-${environmentName}`,
      containerInsights: true,
    });

    // ===========================================
    // IAM Roles
    // ===========================================
    const taskExecutionRole = new iam.Role(this, "TaskExecutionRole", {
      assumedBy: new iam.ServicePrincipal("ecs-tasks.amazonaws.com"),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AmazonECSTaskExecutionRolePolicy"
        ),
      ],
    });

    dbSecret.grantRead(taskExecutionRole);

    const taskRole = new iam.Role(this, "TaskRole", {
      assumedBy: new iam.ServicePrincipal("ecs-tasks.amazonaws.com"),
    });

    // Grant S3 permissions for dynamic bucket creation
    taskRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          "s3:CreateBucket",
          "s3:ListBucket",
          "s3:GetBucketLocation",
          "s3:PutBucketPublicAccessBlock",
          "s3:PutBucketCORS",
          "s3:PutBucketVersioning",
        ],
        resources: ["arn:aws:s3:::crackosaurus-*"],
      })
    );

    taskRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          "s3:PutObject",
          "s3:GetObject",
          "s3:DeleteObject",
          "s3:ListMultipartUploadParts",
          "s3:AbortMultipartUpload",
        ],
        resources: ["arn:aws:s3:::crackosaurus-*/*"],
      })
    );

    // ===========================================
    // Application Load Balancer
    // ===========================================
    const alb = new elbv2.ApplicationLoadBalancer(this, "ALB", {
      vpc,
      internetFacing: true,
      securityGroup: albSecurityGroup,
    });

    const targetGroup = new elbv2.ApplicationTargetGroup(this, "ServerTargetGroup", {
      vpc,
      port: 8080,
      protocol: elbv2.ApplicationProtocol.HTTP,
      targetType: elbv2.TargetType.IP,
      healthCheck: {
        path: "/ping",
        interval: cdk.Duration.seconds(30),
        timeout: cdk.Duration.seconds(5),
        healthyThresholdCount: 2,
        unhealthyThresholdCount: 3,
      },
      deregistrationDelay: cdk.Duration.seconds(30),
    });

    alb.addListener("HttpListener", {
      port: 80,
      protocol: elbv2.ApplicationProtocol.HTTP,
      defaultAction: elbv2.ListenerAction.forward([targetGroup]),
    });

    // ===========================================
    // Server Service
    // ===========================================
    // Budget mode: 0.25 vCPU, 512 MB (~$8/month) vs 1 vCPU, 2 GB (~$30/month)
    const serverTaskDefinition = new ecs.FargateTaskDefinition(this, "ServerTask", {
      cpu: budgetMode ? 256 : 1024,
      memoryLimitMiB: budgetMode ? 512 : 2048,
      executionRole: taskExecutionRole,
      taskRole: taskRole,
    });

    const dbEndpoint = database.dbInstanceEndpointAddress;

    // ECR repositories
    const serverRepository = ecr.Repository.fromRepositoryName(
      this,
      "ServerRepository",
      "crackosaurus/server"
    );
    serverRepository.grantPull(taskExecutionRole);

    serverTaskDefinition.addContainer("server", {
      containerName: "server",
      image: ecs.ContainerImage.fromEcrRepository(serverRepository, "latest"),
      portMappings: [{ containerPort: 8080, protocol: ecs.Protocol.TCP }],
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: "server",
        logRetention: logs.RetentionDays.ONE_WEEK,
      }),
      environment: {
        NODE_ENV: "production",
        DATABASE_PROVIDER: "postgresql",
        DATABASE_PATH: `postgresql://postgres:\${DB_PASSWORD}@${dbEndpoint}:5432/crackosaurus?schema=public`,
        BACKEND_HOST: "0.0.0.0",
        BACKEND_PORT: "8080",
        WEB_HOST: domainName || alb.loadBalancerDnsName,
        WEB_PORT: "80",
        CLUSTER_HOST: "cluster.crackosaurus.local",
        CLUSTER_PORT: "13337",
        AWS_REGION: this.region,
      },
      secrets: {
        DB_PASSWORD: ecs.Secret.fromSecretsManager(dbSecret, "password"),
      },
    });

    const serverService = new ecs.FargateService(this, "ServerService", {
      cluster: ecsCluster,
      taskDefinition: serverTaskDefinition,
      // Budget mode: Only 1 task (no high availability)
      desiredCount: budgetMode ? 1 : (isProduction ? 2 : 1),
      securityGroups: [serverSecurityGroup],
      // Budget mode: Public subnets (no NAT gateway needed)
      vpcSubnets: { 
        subnetType: budgetMode ? ec2.SubnetType.PUBLIC : ec2.SubnetType.PRIVATE_WITH_EGRESS 
      },
      // Budget mode: Assign public IP when in public subnet
      assignPublicIp: budgetMode,
      enableExecuteCommand: true,
      healthCheckGracePeriod: cdk.Duration.seconds(60),
      // Budget mode: Use Fargate Spot (70% cheaper, can be interrupted)
      capacityProviderStrategies: budgetMode ? [
        {
          capacityProvider: "FARGATE_SPOT",
          weight: 1,
        },
      ] : undefined,
    });

    serverService.attachToApplicationTargetGroup(targetGroup);

    // Auto-scaling for production (disabled in budget mode)
    if (isProduction && !budgetMode) {
      const scaling = serverService.autoScaleTaskCount({
        minCapacity: 2,
        maxCapacity: 10,
      });

      scaling.scaleOnCpuUtilization("CpuScaling", {
        targetUtilizationPercent: 70,
        scaleInCooldown: cdk.Duration.seconds(60),
        scaleOutCooldown: cdk.Duration.seconds(60),
      });
    }

    // ===========================================
    // Cluster Service
    // ===========================================
    // Budget mode: 0.5 vCPU, 1 GB (~$15/month) vs 2 vCPU, 4 GB (~$60/month)
    const clusterTaskDefinition = new ecs.FargateTaskDefinition(this, "ClusterTask", {
      cpu: budgetMode ? 512 : 2048,
      memoryLimitMiB: budgetMode ? 1024 : 4096,
      executionRole: taskExecutionRole,
      taskRole: taskRole,
    });

    const clusterRepository = ecr.Repository.fromRepositoryName(
      this,
      "ClusterRepository",
      "crackosaurus/cluster"
    );
    clusterRepository.grantPull(taskExecutionRole);

    clusterTaskDefinition.addContainer("cluster", {
      containerName: "cluster",
      image: ecs.ContainerImage.fromEcrRepository(clusterRepository, "latest"),
      portMappings: [{ containerPort: 13337, protocol: ecs.Protocol.TCP }],
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: "cluster",
        logRetention: logs.RetentionDays.ONE_WEEK,
      }),
      environment: {
        CLUSTER_HOST: "0.0.0.0",
        CLUSTER_PORT: "13337",
        CLUSTER_TYPE: "external",
        AWS_REGION: this.region,
      },
    });

    new ecs.FargateService(this, "ClusterService", {
      cluster: ecsCluster,
      taskDefinition: clusterTaskDefinition,
      desiredCount: 1,
      securityGroups: [clusterSecurityGroup],
      // Budget mode: Public subnets (no NAT gateway needed)
      vpcSubnets: { 
        subnetType: budgetMode ? ec2.SubnetType.PUBLIC : ec2.SubnetType.PRIVATE_WITH_EGRESS 
      },
      // Budget mode: Assign public IP when in public subnet
      assignPublicIp: budgetMode,
      enableExecuteCommand: true,
      // Budget mode: Use Fargate Spot (70% cheaper)
      capacityProviderStrategies: budgetMode ? [
        {
          capacityProvider: "FARGATE_SPOT",
          weight: 1,
        },
      ] : undefined,
      cloudMapOptions: {
        name: "cluster",
        cloudMapNamespace: namespace,
        dnsRecordType: cloudmap.DnsRecordType.A,
        dnsTtl: cdk.Duration.seconds(10),
      },
    });

    // ===========================================
    // DNS (Optional)
    // ===========================================
    if (domainName && props.hostedZoneId) {
      const hostedZone = route53.HostedZone.fromHostedZoneAttributes(
        this,
        "HostedZone",
        {
          hostedZoneId: props.hostedZoneId,
          zoneName: domainName,
        }
      );

      new route53.ARecord(this, "AliasRecord", {
        zone: hostedZone,
        recordName: domainName,
        target: route53.RecordTarget.fromAlias(
          new route53Targets.LoadBalancerTarget(alb)
        ),
      });
    }

    // ===========================================
    // Outputs
    // ===========================================
    new cdk.CfnOutput(this, "LoadBalancerDNS", {
      value: alb.loadBalancerDnsName,
      description: "DNS name of the load balancer",
      exportName: `${id}-LoadBalancerDNS`,
    });

    new cdk.CfnOutput(this, "DatabaseEndpoint", {
      value: database.dbInstanceEndpointAddress,
      description: "RDS database endpoint",
      exportName: `${id}-DatabaseEndpoint`,
    });

    new cdk.CfnOutput(this, "DatabaseSecretArn", {
      value: dbSecret.secretArn,
      description: "ARN of the database password secret",
      exportName: `${id}-DatabaseSecretArn`,
    });

    new cdk.CfnOutput(this, "ClusterName", {
      value: ecsCluster.clusterName,
      description: "ECS cluster name",
      exportName: `${id}-ClusterName`,
    });

    if (domainName) {
      new cdk.CfnOutput(this, "ApplicationURL", {
        value: `http://${domainName}`,
        description: "Application URL",
      });
    }
  }
}
